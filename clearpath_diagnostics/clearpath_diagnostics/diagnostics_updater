#!/usr/bin/env python3

# Software License Agreement (BSD)
#
# @author    Roni Kreinin <rkreinin@clearpathrobotics.com>
# @copyright (c) 2023, Clearpath Robotics, Inc., All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of Clearpath Robotics nor the names of its contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Redistribution and use in source and binary forms, with or without
# modification, is not permitted without the express permission
# of Clearpath Robotics.

import os

from diagnostic_msgs.msg import DiagnosticStatus

from diagnostic_updater import FrequencyStatusParam, HeaderlessTopicDiagnostic, Updater, DiagnosticStatusWrapper

import rclpy
from rclpy.node import Node
from rclpy.qos import qos_profile_sensor_data

from sensor_msgs.msg import BatteryState, Image, Imu, LaserScan, PointCloud2

from clearpath_generator_common.common import BaseGenerator
from clearpath_config.common.utils.yaml import read_yaml
from clearpath_config.clearpath_config import ClearpathConfig
from clearpath_config.sensors.types.sensor import BaseSensor
from clearpath_config.sensors.types.cameras import BaseCamera
from clearpath_config.sensors.types.lidars_2d import BaseLidar2D
from clearpath_config.sensors.types.lidars_3d import BaseLidar3D

from clearpath_platform_msgs.msg import Status


class ClearpathDiagnosticUpdater(Node):

    def __init__(self, setup_path: str = '/etc/clearpath/'):
        super().__init__('clearpath_diagnostics_updater')
        self.setup_path = setup_path

        # Define paths
        self.config_path = os.path.join(setup_path, 'robot.yaml')
        assert os.path.exists(self.config_path)

        # Read YAML
        self.config = read_yaml(self.config_path)
        # Parse YAML into config
        self.clearpath_config = ClearpathConfig(self.config)

        self.serial_number = self.clearpath_config.serial_number
        self.platform_model = self.clearpath_config.platform.get_platform_model()
        self.namespace = self.clearpath_config.system.namespace

        # Create updater
        self.updater = Updater(self)
        self.updater.setHardwareID(self.serial_number)

        # Subscribe to topics
        self.status_sub = self.create_subscription(
            Status,
            'platform/mcu/status',
            self.status_callback,
            qos_profile_sensor_data
        )

        self.camera_freq_bounds = {'min': 5, 'max': 10}
        self.lidar2d_freq_bounds = {'min': 5, 'max': 10}
        self.lidar3d_freq_bounds = {'min': 5, 'max': 10}

        for sensor in self.clearpath_config.sensors.get_all_sensors():
            self.add_sensor_diagnostic(sensor)

        # Initial values
        self.firmware_version = '0.0.0'
        self.newest_firmware_version = '0.0.1'
        self.battery_percentage = 0.0
        self.battery_voltage = 0.0

        # Add Diagnostic status
        self.updater.add('Firmware Version', self.check_firmware_version)

        self.updater.force_update()

    def status_callback(self, msg: Status):
        self.firmware_version = msg.firmware_commit
        self.mcu_temperature = msg.mcu_temperature
        self.pcb_temperature = msg.pcb_temperature

    def check_firmware_version(self, stat: DiagnosticStatusWrapper):
        if self.firmware_version == '0.0.1':
            stat.summary(DiagnosticStatus.OK, f'Firmware is up to date (v{self.firmware_version})')
        else:
            stat.summary(DiagnosticStatus.WARN, f'New firmware available. (v{self.firmware_version}) -> (v{self.newest_firmware_version})')
        return stat

    def add_sensor_diagnostic(self, sensor: BaseSensor):
        if self.namespace in ('', '/'):
            topic = f'sensors/{sensor.name}'
        else:
            topic = f'{self.namespace}/sensors/{sensor.name}'

        freq_bounds = {}
        message_type = None
        sensor_type = sensor.get_sensor_type()

        if sensor_type == BaseCamera.SENSOR_TYPE:
            freq_bounds = self.camera_freq_bounds
            message_type = Image
        elif sensor_type == BaseLidar2D.SENSOR_TYPE:
            freq_bounds = self.lidar2d_freq_bounds
            message_type = LaserScan
        elif sensor_type == BaseLidar3D.SENSOR_TYPE:
            freq_bounds = self.lidar3d_freq_bounds
            message_type = PointCloud2

        diagnostic = HeaderlessTopicDiagnostic(
                      topic,
                      self.updater,
                      FrequencyStatusParam(freq_bounds, 0.1, 10))

        self.create_subscription(
            message_type,
            topic,
            lambda msg: diagnostic.tick(),
            qos_profile_sensor_data
        )


def main():
    setup_path = BaseGenerator.get_args()

    rclpy.init()

    node = ClearpathDiagnosticUpdater(setup_path)
    rclpy.spin(node)

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
